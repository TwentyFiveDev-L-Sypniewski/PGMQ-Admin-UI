@using Microsoft.FluentUI.AspNetCore.Components
@inject QueueService QueueService
@inject IMessageService MessageService
@inject ILogger<MetricsTab> Logger
@implements IDisposable

<FluentStack Orientation="Orientation.Vertical">
    <h3>Queue Metrics</h3>

    @if (_loading)
    {
        <FluentProgressRing />
    }
    else if (_stats == null)
    {
        <FluentMessageBar Intent="MessageIntent.Error">
            Failed to load metrics.
        </FluentMessageBar>
    }
    else
    {
        <div class="metrics-container">
            <div class="metrics-grid">
                <FluentCard Class="metric-card">
                    <h4>Queue Length</h4>
                    <p class="metric-value">@_stats.QueueLength</p>
                    <p class="metric-label">Current messages</p>
                </FluentCard>

                <FluentCard Class="metric-card">
                    <h4>Total Messages</h4>
                    <p class="metric-value">@_stats.TotalMessages</p>
                    <p class="metric-label">All-time</p>
                </FluentCard>

                <FluentCard Class="metric-card">
                    <h4>Oldest Message Age</h4>
                    <p class="metric-value">@FormatAge(_stats.OldestMsgAgeSec)</p>
                    <p class="metric-label">Seconds</p>
                </FluentCard>

                <FluentCard Class="metric-card">
                    <h4>Newest Message Age</h4>
                    <p class="metric-value">@FormatAge(_stats.NewestMsgAgeSec)</p>
                    <p class="metric-label">Seconds</p>
                </FluentCard>

                <FluentCard Class="metric-card">
                    <h4>Last Scrape</h4>
                    <p class="metric-value-small">@_stats.ScrapeTime.ToString("HH:mm:ss")</p>
                    <p class="metric-label">UTC</p>
                </FluentCard>
            </div>
        </div>

        <p class="auto-refresh-hint">
            Auto-refreshing every 30 seconds
        </p>
    }
</FluentStack>

@code {
    [Parameter] public required string QueueName { get; set; }

    private QueueStatsDto? _stats;
    private bool _loading = true;
    private PeriodicTimer? _timer;

    protected override async Task OnInitializedAsync()
    {
        await LoadMetricsAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _timer = new PeriodicTimer(TimeSpan.FromSeconds(30));

            while (await _timer.WaitForNextTickAsync())
            {
                await LoadMetricsAsync();
            }
        }
    }

    private async Task LoadMetricsAsync()
    {
        try
        {
            _loading = true;
            _stats = await QueueService.GetQueueStatsAsync(QueueName);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load metrics for queue {QueueName}", QueueName);
            MessageService.ShowMessageBar(options => {
                options.Intent = MessageIntent.Error;
                options.Body = $"Failed to load metrics: {ex.Message}";
            });
        }
        finally
        {
            _loading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private string FormatAge(int? seconds) =>
        seconds.HasValue ? $"{seconds.Value:N0}" : "N/A";

    public void Dispose()
    {
        _timer?.Dispose();
    }
}
